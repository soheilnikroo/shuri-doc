"use strict";(self.webpackChunkshu_doc=self.webpackChunkshu_doc||[]).push([[660],{8211:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"commands","title":"Commands","description":"Master the art of creating powerful CLI commands","source":"@site/docs/commands.md","sourceDirName":".","slug":"/commands","permalink":"/shuri-doc/docs/commands","draft":false,"unlisted":false,"editUrl":"https://github.com/soheilnikroo/shuri-doc/edit/main/docs/commands.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Commands","description":"Master the art of creating powerful CLI commands"},"sidebar":"tutorialSidebar","previous":{"title":"Creating Packages","permalink":"/shuri-doc/docs/creating-packages"}}');var o=t(3420),s=t(9932);const r={sidebar_position:5,title:"Commands",description:"Master the art of creating powerful CLI commands"},a="\u26a1 Commands",c={},l=[{value:"Command Anatomy",id:"command-anatomy",level:2},{value:"Command Definition Interface",id:"command-definition-interface",level:2},{value:"Command Options",id:"command-options",level:2},{value:"Basic Options",id:"basic-options",level:3},{value:"Advanced Options",id:"advanced-options",level:3},{value:"Command Arguments",id:"command-arguments",level:2},{value:"Command Types",id:"command-types",level:2},{value:"1. Simple Commands",id:"1-simple-commands",level:3},{value:"2. Interactive Commands",id:"2-interactive-commands",level:3},{value:"3. File Processing Commands",id:"3-file-processing-commands",level:3},{value:"4. API Integration Commands",id:"4-api-integration-commands",level:3},{value:"Command Validation",id:"command-validation",level:2},{value:"Input Validation",id:"input-validation",level:3},{value:"Custom Validation Rules",id:"custom-validation-rules",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Graceful Error Handling",id:"graceful-error-handling",level:3},{value:"Progress Indicators",id:"progress-indicators",level:2},{value:"Long-Running Operations",id:"long-running-operations",level:3},{value:"Progress Bars",id:"progress-bars",level:3},{value:"Command Composition",id:"command-composition",level:2},{value:"Calling Other Commands",id:"calling-other-commands",level:3},{value:"Testing Commands",id:"testing-commands",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. User Experience",id:"1-user-experience",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Performance",id:"3-performance",level:3},{value:"4. Documentation",id:"4-documentation",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"-commands",children:"\u26a1 Commands"})}),"\n",(0,o.jsx)(e.p,{children:"Commands are the heart of your Shuriken CLI packages. Learn how to create powerful, user-friendly commands that handle complex workflows with ease."}),"\n",(0,o.jsx)(e.h2,{id:"command-anatomy",children:"Command Anatomy"}),"\n",(0,o.jsx)(e.p,{children:"Every command in Shuriken CLI follows this structure:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"import type { ICommandDefinition } from '@/types';\nimport { injectable, inject } from 'inversify';\n\n@injectable()\nexport class MyCommand implements ICommandHandler {\n  constructor(@inject('Logger') private logger: Logger) {}\n\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    // Command implementation\n  }\n}\n\nconst myCommand: ICommandDefinition = {\n  name: 'my-command',\n  description: 'Does something awesome',\n  options: [], // Command options\n  arguments: [], // Command arguments\n  handler: MyCommand,\n};\n\nexport default myCommand;\n"})}),"\n",(0,o.jsx)(e.h2,{id:"command-definition-interface",children:"Command Definition Interface"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"interface ICommandDefinition {\n  name: string; // Command name\n  description: string; // Help text description\n  options?: ICommandOption[]; // Optional flags\n  arguments?: ICommandArgument[]; // Positional arguments\n  handler: new (...args: any[]) => ICommandHandler; // Command class\n  hidden?: boolean; // Hide from help\n  aliases?: string[]; // Alternative names\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"command-options",children:"Command Options"}),"\n",(0,o.jsx)(e.p,{children:"Options are flags that modify command behavior:"}),"\n",(0,o.jsx)(e.h3,{id:"basic-options",children:"Basic Options"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"const options: ICommandOption[] = [\n  {\n    name: 'env', // --env\n    alias: 'e', // -e (short alias)\n    type: 'string', // Value type\n    description: 'Environment to deploy to',\n    required: false, // Optional by default\n    default: 'production', // Default value\n  },\n  {\n    name: 'verbose', // --verbose\n    alias: 'v', // -v\n    type: 'boolean', // Boolean flag\n    description: 'Enable verbose logging',\n    default: false,\n  },\n  {\n    name: 'port', // --port\n    alias: 'p', // -p\n    type: 'number', // Numeric value\n    description: 'Port number to use',\n    default: 3000,\n  },\n];\n"})}),"\n",(0,o.jsx)(e.h3,{id:"advanced-options",children:"Advanced Options"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"const advancedOptions: ICommandOption[] = [\n  {\n    name: 'format',\n    type: 'string',\n    description: 'Output format',\n    choices: ['json', 'yaml', 'table'], // Restrict to specific values\n    default: 'table',\n  },\n  {\n    name: 'config',\n    type: 'string',\n    description: 'Path to config file',\n    required: true, // Required option\n    validate: (value: string) => {\n      // Custom validation\n      return value.endsWith('.json') || 'Config must be a JSON file';\n    },\n  },\n  {\n    name: 'include',\n    type: 'array', // Array of strings\n    description: 'Files to include',\n    default: [],\n  },\n];\n"})}),"\n",(0,o.jsx)(e.h2,{id:"command-arguments",children:"Command Arguments"}),"\n",(0,o.jsx)(e.p,{children:"Arguments are positional parameters:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"const arguments: ICommandArgument[] = [\n  {\n    name: 'component-name', // First argument\n    description: 'Name of the component',\n    required: true, // Must be provided\n    validate: (value: string) => {\n      return /^[A-Z][a-zA-Z0-9]*$/.test(value) || 'Must be PascalCase';\n    },\n  },\n  {\n    name: 'output-dir', // Second argument\n    description: 'Output directory',\n    required: false, // Optional argument\n    default: './src/components',\n  },\n];\n"})}),"\n",(0,o.jsx)(e.h2,{id:"command-types",children:"Command Types"}),"\n",(0,o.jsx)(e.h3,{id:"1-simple-commands",children:"1. Simple Commands"}),"\n",(0,o.jsx)(e.p,{children:"Basic commands that perform a single task:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"@injectable()\nexport class BuildCommand {\n  constructor(\n    @inject('Logger') private logger: Logger,\n    @inject('ProcessService') private process: ProcessService\n  ) {}\n\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    this.logger.info('\ud83d\udd28 Building project...');\n\n    const buildCommand = options.watch ? 'build:watch' : 'build';\n    await this.process.run('npm', ['run', buildCommand], {\n      cwd: context.workingDirectory,\n    });\n\n    this.logger.success('\u2705 Build completed!');\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"2-interactive-commands",children:"2. Interactive Commands"}),"\n",(0,o.jsx)(e.p,{children:"Commands that prompt users for input:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"@injectable()\nexport class GenerateCommand {\n  constructor(\n    @inject('Logger') private logger: Logger,\n    @inject('PromptService') private prompt: PromptService,\n    @inject('FileService') private fileService: FileService\n  ) {}\n\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    // Gather requirements through prompts\n    const config = await this.gatherRequirements(options);\n\n    // Generate files based on config\n    await this.generateFiles(config, context);\n\n    this.logger.success('\u2705 Generation completed!');\n  }\n\n  private async gatherRequirements(options: any): Promise<any> {\n    const questions = [\n      {\n        type: 'input',\n        name: 'name',\n        message: 'Component name:',\n        when: !options.name,\n        validate: (input: string) => {\n          if (!input.trim()) return 'Name is required';\n          if (!/^[A-Z][a-zA-Z0-9]*$/.test(input)) return 'Must be PascalCase';\n          return true;\n        },\n      },\n      {\n        type: 'list',\n        name: 'type',\n        message: 'Component type:',\n        choices: [\n          { name: 'Functional Component', value: 'functional' },\n          { name: 'Class Component', value: 'class' },\n          { name: 'Custom Hook', value: 'hook' },\n        ],\n        default: 'functional',\n      },\n      {\n        type: 'checkbox',\n        name: 'features',\n        message: 'Include features:',\n        choices: [\n          { name: 'TypeScript', value: 'typescript', checked: true },\n          { name: 'CSS Modules', value: 'styles' },\n          { name: 'Unit Tests', value: 'tests', checked: true },\n          { name: 'Storybook Stories', value: 'stories' },\n        ],\n      },\n    ];\n\n    return this.prompt.ask(questions);\n  }\n\n  private async generateFiles(\n    config: any,\n    context: IProjectContext\n  ): Promise<void> {\n    const outputDir = path.join(\n      context.workingDirectory,\n      'src/components',\n      config.name\n    );\n\n    // Create component directory\n    await this.fileService.ensureDir(outputDir);\n\n    // Generate main component file\n    const componentContent = this.generateComponentContent(config);\n    await this.fileService.writeFile(\n      path.join(\n        outputDir,\n        `${config.name}.${\n          config.features.includes('typescript') ? 'tsx' : 'jsx'\n        }`\n      ),\n      componentContent\n    );\n\n    // Generate additional files based on features\n    if (config.features.includes('styles')) {\n      await this.generateStylesFile(outputDir, config.name);\n    }\n\n    if (config.features.includes('tests')) {\n      await this.generateTestFile(outputDir, config);\n    }\n\n    if (config.features.includes('stories')) {\n      await this.generateStoryFile(outputDir, config);\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"3-file-processing-commands",children:"3. File Processing Commands"}),"\n",(0,o.jsx)(e.p,{children:"Commands that work with files and directories:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"@injectable()\nexport class MigrateCommand {\n  constructor(\n    @inject('Logger') private logger: Logger,\n    @inject('FileService') private fileService: FileService\n  ) {}\n\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    const sourceDir = path.join(context.workingDirectory, 'src');\n\n    // Find all files to migrate\n    const jsFiles = await this.fileService.glob('**/*.{js,jsx}', {\n      cwd: sourceDir,\n      absolute: true,\n    });\n\n    this.logger.info(`\ud83d\udcc1 Found ${jsFiles.length} JavaScript files to migrate`);\n\n    // Process files in batches\n    const batchSize = 10;\n    for (let i = 0; i < jsFiles.length; i += batchSize) {\n      const batch = jsFiles.slice(i, i + batchSize);\n      await this.processBatch(batch, options);\n\n      this.logger.info(\n        `\u2705 Processed ${Math.min(i + batchSize, jsFiles.length)}/${\n          jsFiles.length\n        } files`\n      );\n    }\n\n    this.logger.success('\ud83c\udf89 Migration completed successfully!');\n  }\n\n  private async processBatch(files: string[], options: any): Promise<void> {\n    const promises = files.map((file) => this.migrateFile(file, options));\n    await Promise.all(promises);\n  }\n\n  private async migrateFile(filePath: string, options: any): Promise<void> {\n    try {\n      const content = await this.fileService.readFile(filePath);\n      const migratedContent = this.applyMigrations(content, options);\n\n      // Rename .js to .ts / .jsx to .tsx\n      const newPath = filePath.replace(/\\.jsx?$/, (match) =>\n        match === '.js' ? '.ts' : '.tsx'\n      );\n\n      await this.fileService.writeFile(newPath, migratedContent);\n\n      if (newPath !== filePath) {\n        await this.fileService.remove(filePath);\n      }\n    } catch (error) {\n      this.logger.error(`\u274c Failed to migrate ${filePath}: ${error.message}`);\n      if (!options.continueOnError) {\n        throw error;\n      }\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"4-api-integration-commands",children:"4. API Integration Commands"}),"\n",(0,o.jsx)(e.p,{children:"Commands that interact with external services:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"@injectable()\nexport class DeployCommand {\n  constructor(\n    @inject('Logger') private logger: Logger,\n    @inject('HttpService') private http: HttpService,\n    @inject('ConfigService') private config: ConfigService\n  ) {}\n\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    // Authenticate with deployment service\n    const apiKey = await this.config.get('deploy.apiKey');\n    if (!apiKey) {\n      throw new Error('API key not configured. Run setup first.');\n    }\n\n    // Build the project\n    this.logger.info('\ud83d\udd28 Building project for deployment...');\n    await this.buildProject(context);\n\n    // Create deployment\n    this.logger.info('\ud83d\ude80 Creating deployment...');\n    const deployment = await this.createDeployment(apiKey, options);\n\n    // Monitor deployment status\n    this.logger.info('\u23f3 Monitoring deployment...');\n    await this.monitorDeployment(deployment.id, apiKey);\n\n    this.logger.success(`\ud83c\udf89 Deployed successfully to ${deployment.url}`);\n  }\n\n  private async createDeployment(apiKey: string, options: any): Promise<any> {\n    const response = await this.http.post(\n      '/deployments',\n      {\n        environment: options.env,\n        branch: options.branch || 'main',\n        buildCommand: options.buildCommand || 'npm run build',\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n        },\n      }\n    );\n\n    return response.data;\n  }\n\n  private async monitorDeployment(\n    deploymentId: string,\n    apiKey: string\n  ): Promise<void> {\n    const maxAttempts = 60; // 5 minutes with 5-second intervals\n    let attempts = 0;\n\n    while (attempts < maxAttempts) {\n      const status = await this.getDeploymentStatus(deploymentId, apiKey);\n\n      if (status === 'success') {\n        return;\n      } else if (status === 'failed') {\n        throw new Error('Deployment failed');\n      }\n\n      // Wait 5 seconds before checking again\n      await new Promise((resolve) => setTimeout(resolve, 5000));\n      attempts++;\n    }\n\n    throw new Error('Deployment timeout');\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"command-validation",children:"Command Validation"}),"\n",(0,o.jsx)(e.h3,{id:"input-validation",children:"Input Validation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"export class ValidatedCommand {\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    // Validate environment\n    await this.validateEnvironment(context);\n\n    // Validate options\n    this.validateOptions(options);\n\n    // Validate project state\n    await this.validateProjectState(context);\n\n    // Execute command\n    await this.executeCommand(options, context);\n  }\n\n  private validateOptions(options: any): void {\n    // Validate port number\n    if (options.port && (options.port < 1 || options.port > 65535)) {\n      throw new ValidationError('Port must be between 1 and 65535');\n    }\n\n    // Validate environment\n    const validEnvs = ['development', 'staging', 'production'];\n    if (options.env && !validEnvs.includes(options.env)) {\n      throw new ValidationError(\n        `Invalid environment: ${options.env}. Must be one of: ${validEnvs.join(\n          ', '\n        )}`\n      );\n    }\n\n    // Validate file paths\n    if (options.config && !path.isAbsolute(options.config)) {\n      options.config = path.resolve(process.cwd(), options.config);\n    }\n  }\n\n  private async validateProjectState(context: IProjectContext): Promise<void> {\n    // Check if package.json exists\n    const packageJsonPath = path.join(context.workingDirectory, 'package.json');\n    if (!(await this.fileService.exists(packageJsonPath))) {\n      throw new ValidationError(\n        'No package.json found. Are you in a valid project directory?'\n      );\n    }\n\n    // Validate package.json content\n    const packageJson = await this.fileService.readJson(packageJsonPath);\n    if (!packageJson.name) {\n      throw new ValidationError('package.json must have a name field');\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"custom-validation-rules",children:"Custom Validation Rules"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"const commandOptions: ICommandOption[] = [\n  {\n    name: 'email',\n    type: 'string',\n    description: 'Email address',\n    validate: (value: string) => {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      return emailRegex.test(value) || 'Please enter a valid email address';\n    },\n  },\n  {\n    name: 'version',\n    type: 'string',\n    description: 'Version number',\n    validate: (value: string) => {\n      const semverRegex = /^\\d+\\.\\d+\\.\\d+$/;\n      return (\n        semverRegex.test(value) || 'Version must be in semver format (x.y.z)'\n      );\n    },\n  },\n];\n"})}),"\n",(0,o.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(e.h3,{id:"graceful-error-handling",children:"Graceful Error Handling"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"export class RobustCommand {\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    try {\n      await this.performOperation(options, context);\n    } catch (error) {\n      await this.handleError(error, options, context);\n    }\n  }\n\n  private async handleError(\n    error: Error,\n    options: any,\n    context: IProjectContext\n  ): Promise<void> {\n    if (error instanceof ValidationError) {\n      this.logger.error(`\u274c ${error.message}`);\n      this.showSuggestions(error.suggestions);\n    } else if (error.code === 'ENOENT') {\n      this.logger.error(`\u274c File not found: ${error.path}`);\n      this.logger.info(\n        '\ud83d\udca1 Make sure the file exists and you have read permissions'\n      );\n    } else if (error.code === 'EACCES') {\n      this.logger.error('\u274c Permission denied');\n      this.logger.info(\n        '\ud83d\udca1 Try running the command with appropriate permissions'\n      );\n    } else {\n      this.logger.error(`\u274c Unexpected error: ${error.message}`);\n\n      if (options.debug) {\n        this.logger.debug('Stack trace:', error.stack);\n      } else {\n        this.logger.info('\ud83d\udca1 Run with --debug for more details');\n      }\n    }\n\n    process.exit(1);\n  }\n\n  private showSuggestions(suggestions: string[]): void {\n    if (suggestions.length > 0) {\n      this.logger.info('\ud83d\udca1 Suggestions:');\n      suggestions.forEach((suggestion, index) => {\n        this.logger.info(`   ${index + 1}. ${suggestion}`);\n      });\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"progress-indicators",children:"Progress Indicators"}),"\n",(0,o.jsx)(e.h3,{id:"long-running-operations",children:"Long-Running Operations"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"import { createSpinner } from 'nanospinner';\n\nexport class ProgressCommand {\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    const spinner = createSpinner('Initializing...').start();\n\n    try {\n      // Step 1: Setup\n      spinner.update({ text: 'Setting up environment...' });\n      await this.setupEnvironment();\n\n      // Step 2: Process files\n      spinner.update({ text: 'Processing files...' });\n      await this.processFiles();\n\n      // Step 3: Cleanup\n      spinner.update({ text: 'Cleaning up...' });\n      await this.cleanup();\n\n      spinner.success({ text: 'Operation completed successfully!' });\n    } catch (error) {\n      spinner.error({ text: `Operation failed: ${error.message}` });\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"progress-bars",children:"Progress Bars"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"import { MultiBar, Presets } from 'cli-progress';\n\nexport class BatchProcessCommand {\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    const files = await this.getFilesToProcess();\n\n    // Create progress bar\n    const multibar = new MultiBar(\n      {\n        clearOnComplete: false,\n        hideCursor: true,\n        format: ' {bar} | {filename} | {value}/{total}',\n      },\n      Presets.shades_classic\n    );\n\n    const progressBar = multibar.create(files.length, 0);\n\n    // Process files with progress updates\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      progressBar.update(i + 1, { filename: path.basename(file) });\n\n      await this.processFile(file);\n    }\n\n    multibar.stop();\n    this.logger.success(`\u2705 Processed ${files.length} files`);\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"command-composition",children:"Command Composition"}),"\n",(0,o.jsx)(e.h3,{id:"calling-other-commands",children:"Calling Other Commands"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"@injectable()\nexport class WorkflowCommand {\n  constructor(\n    @inject('CommandManager') private commandManager: CommandManager\n  ) {}\n\n  async execute(options: any, context: IProjectContext): Promise<void> {\n    // Step 1: Setup\n    await this.commandManager.executeCommand('setup', options, context);\n\n    // Step 2: Build\n    await this.commandManager.executeCommand(\n      'build',\n      {\n        ...options,\n        env: 'production',\n      },\n      context\n    );\n\n    // Step 3: Test\n    if (options.runTests) {\n      await this.commandManager.executeCommand(\n        'test',\n        {\n          coverage: true,\n        },\n        context\n      );\n    }\n\n    // Step 4: Deploy\n    if (options.deploy) {\n      await this.commandManager.executeCommand(\n        'deploy',\n        {\n          env: options.env || 'staging',\n        },\n        context\n      );\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"testing-commands",children:"Testing Commands"}),"\n",(0,o.jsx)(e.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// commands/__tests__/build.test.ts\nimport { Container } from 'inversify';\nimport { BuildCommand } from '../build';\nimport { Logger } from '@/core/logger';\nimport { ProcessService } from '@/core/process';\n\ndescribe('BuildCommand', () => {\n  let command: BuildCommand;\n  let mockLogger: jest.Mocked<Logger>;\n  let mockProcess: jest.Mocked<ProcessService>;\n\n  beforeEach(() => {\n    const container = new Container();\n\n    mockLogger = {\n      info: jest.fn(),\n      success: jest.fn(),\n      error: jest.fn(),\n    } as any;\n\n    mockProcess = {\n      run: jest.fn().mockResolvedValue({ code: 0 }),\n    } as any;\n\n    container.bind('Logger').toConstantValue(mockLogger);\n    container.bind('ProcessService').toConstantValue(mockProcess);\n\n    command = container.resolve(BuildCommand);\n  });\n\n  it('should build successfully', async () => {\n    const options = { env: 'production' };\n    const context = { workingDirectory: '/test/project' };\n\n    await command.execute(options, context);\n\n    expect(mockLogger.info).toHaveBeenCalledWith('\ud83d\udd28 Building project...');\n    expect(mockProcess.run).toHaveBeenCalledWith('npm', ['run', 'build'], {\n      cwd: '/test/project',\n    });\n    expect(mockLogger.success).toHaveBeenCalledWith('\u2705 Build completed!');\n  });\n\n  it('should handle build failures', async () => {\n    mockProcess.run.mockRejectedValue(new Error('Build failed'));\n\n    const options = { env: 'production' };\n    const context = { workingDirectory: '/test/project' };\n\n    await expect(command.execute(options, context)).rejects.toThrow(\n      'Build failed'\n    );\n  });\n});\n"})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"1-user-experience",children:"1. User Experience"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Clear feedback"}),": Always inform users what's happening"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Progress indicators"}),": Show progress for long operations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Helpful errors"}),": Provide actionable error messages"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Consistent styling"}),": Use consistent emoji and formatting"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Graceful degradation"}),": Handle errors without crashing"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Contextual help"}),": Provide relevant suggestions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Debug information"}),": Include debug mode for troubleshooting"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Exit codes"}),": Use appropriate exit codes for different failure types"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"3-performance",children:"3. Performance"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Lazy loading"}),": Only load what's needed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Parallel processing"}),": Use async operations where possible"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Caching"}),": Cache expensive operations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Memory management"}),": Clean up resources properly"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"4-documentation",children:"4. Documentation"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Clear descriptions"}),": Write helpful command descriptions"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Example usage"}),": Include usage examples in help text"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Option documentation"}),": Explain all options clearly"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Migration guides"}),": Document breaking changes"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"Now that you've mastered commands:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\ud83d\udd04 ",(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/",children:"Learn Migration System"})})," - Handle version upgrades gracefully"]}),"\n",(0,o.jsxs)(e.li,{children:["\ud83d\udca1 ",(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/",children:"Explore Examples"})})," - See complete real-world implementations"]}),"\n",(0,o.jsxs)(e.li,{children:["\ud83c\udf1f ",(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/",children:"Follow Best Practices"})})," - Build maintainable commands"]}),"\n",(0,o.jsxs)(e.li,{children:["\ud83d\udd27 ",(0,o.jsx)(e.strong,{children:(0,o.jsx)(e.a,{href:"/",children:"API Reference"})})," - Dive into the technical details"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.p,{children:"Ready to handle version upgrades like a ninja? Let's learn about migrations! \ud83e\udd77"})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},9932:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>a});var i=t(6672);const o={},s=i.createContext(o);function r(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);