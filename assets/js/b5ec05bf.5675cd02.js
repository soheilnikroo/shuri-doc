"use strict";(self.webpackChunkshu_doc=self.webpackChunkshu_doc||[]).push([[933],{2412:(e,n,t)=>{t.r(n),t.d(n,{default:()=>a});var o=t(8244),i=t(6672),r=t(3420);const s=[{id:"package-structure",title:"Package Structure",description:"Learn how to organize your package files and directories",icon:"\ud83d\udcc1",examples:[{title:"Basic Package Structure",description:"The recommended directory structure for a new package",language:"bash",code:"packages/\n\u2514\u2500\u2500 my-package/\n    \u251c\u2500\u2500 commands/           # Command implementations\n    \u2502   \u251c\u2500\u2500 setup.ts\n    \u2502   \u251c\u2500\u2500 build.ts\n    \u2502   \u2514\u2500\u2500 deploy.ts\n    \u251c\u2500\u2500 core/              # Shared utilities\n    \u2502   \u251c\u2500\u2500 file.ts\n    \u2502   \u251c\u2500\u2500 logger.ts\n    \u2502   \u2514\u2500\u2500 process.ts\n    \u251c\u2500\u2500 migrations/        # Version migrations\n    \u2502   \u251c\u2500\u2500 1.0.0.ts\n    \u2502   \u2514\u2500\u2500 1.1.0.ts\n    \u251c\u2500\u2500 templates/         # Code templates\n    \u2502   \u251c\u2500\u2500 component.ts\n    \u2502   \u2514\u2500\u2500 service.ts\n    \u2514\u2500\u2500 index.ts          # Package definition"},{title:"Package Definition (index.ts)",description:"How to define your package metadata and export commands",language:"typescript",filename:"packages/my-package/index.ts",code:"import type { IPackageDefinition } from '@/types';\n\nimport setupCommand from '/commands/setup';\nimport buildCommand from '/commands/build';\nimport deployCommand from '/commands/deploy';\nimport { migrations } from '/commands';\n\nconst packageDefinition: IPackageDefinition = {\n  metadata: {\n    name: 'my-package',\n    version: '1.2.0',\n    description: 'A powerful development toolkit for modern applications',\n  },\n  commands: [\n    setupCommand,\n    buildCommand,\n    deployCommand,\n  ],\n  migrations,\n};\n\nexport default packageDefinition;"}]},{id:"creating-commands",title:"Creating Commands",description:"Build powerful CLI commands with options, arguments, and validation",icon:"\u26a1",examples:[{title:"Basic Command Structure",description:"Template for creating a new command",language:"typescript",filename:"packages/my-package/commands/build.ts",code:"import type { ICommandDefinition } from '@/types';\nimport { injectable } from 'inversify';\n\n@injectable()\nexport class BuildCommand {\n  async execute(options: any, context: any): Promise<void> {\n    // Command implementation here\n    console.log('Building project...');\n  }\n}\n\nconst buildCommand: ICommandDefinition = {\n  name: 'build',\n  description: 'Build the project for production',\n  options: [\n    {\n      name: 'env',\n      alias: 'e',\n      type: 'string',\n      description: 'Environment to build for',\n      default: 'production',\n    },\n    {\n      name: 'watch',\n      alias: 'w',\n      type: 'boolean',\n      description: 'Watch for file changes',\n      default: false,\n    },\n  ],\n  handler: BuildCommand,\n};\n\nexport default buildCommand;"},{title:"Interactive Command with Prompts",description:"Command that uses prompts to gather user input",language:"typescript",filename:"packages/jarvis/commands/component.ts",code:"import type { ICommandDefinition } from '@/types';\nimport { injectable, inject } from 'inversify';\nimport { PromptService } from '@/services/prompt';\nimport { Logger } from '@/core/logger';\n\n@injectable()\nexport class ComponentCommand {\n  constructor(\n    @inject('PromptService') private prompt: PromptService,\n    @inject('Logger') private logger: Logger\n  ) {}\n\n  async execute(options: any, context: any): Promise<void> {\n    // Get component details from user\n    const answers = await this.prompt.ask([\n      {\n        type: 'input',\n        name: 'componentName',\n        message: 'What is the component name?',\n        validate: (input: string) => {\n          if (!input.trim()) return 'Component name is required';\n          if (!/^[A-Z][a-zA-Z0-9]*$/.test(input)) {\n            return 'Component name must be PascalCase';\n          }\n          return true;\n        },\n      },\n      {\n        type: 'list',\n        name: 'componentType',\n        message: 'What type of component?',\n        choices: ['Functional', 'Class', 'Hook'],\n        default: 'Functional',\n      },\n      {\n        type: 'confirm',\n        name: 'includeTests',\n        message: 'Include test files?',\n        default: true,\n      },\n    ]);\n\n    this.logger.info(`\ud83d\ude80 Generating ${answers.componentType} component: ${answers.componentName}`);\n    \n    // Generate component files\n    await this.generateComponent(answers);\n    \n    this.logger.success(`\u2705 Component '${answers.componentName}' created successfully!`);\n  }\n\n  private async generateComponent(config: any): Promise<void> {\n    // Component generation logic here\n  }\n}\n\nconst componentCommand: ICommandDefinition = {\n  name: 'component',\n  description: 'Generate a React component with templates',\n  arguments: [\n    {\n      name: 'name',\n      description: 'Component name (optional if using interactive mode)',\n      required: false,\n    },\n  ],\n  options: [\n    {\n      name: 'type',\n      alias: 't',\n      type: 'string',\n      description: 'Component type (functional, class, hook)',\n      choices: ['functional', 'class', 'hook'],\n    },\n    {\n      name: 'no-tests',\n      type: 'boolean',\n      description: 'Skip generating test files',\n      default: false,\n    },\n  ],\n  handler: ComponentCommand,\n};\n\nexport default componentCommand;"},{title:"File Processing Command",description:"Command that processes files and directories",language:"typescript",filename:"packages/my-package/commands/migrate.ts",code:"import type { ICommandDefinition } from '@/types';\nimport { injectable, inject } from 'inversify';\nimport { FileService } from '@/core/file';\nimport { Logger } from '@/core/logger';\nimport path from 'path';\n\n@injectable()\nexport class MigrateCommand {\n  constructor(\n    @inject('FileService') private fileService: FileService,\n    @inject('Logger') private logger: Logger\n  ) {}\n\n  async execute(options: any, context: any): Promise<void> {\n    const { version, force } = options;\n    \n    this.logger.info('\ud83d\udd04 Starting migration process...');\n    \n    // Find migration files\n    const migrationsDir = path.join(context.packagePath, 'migrations');\n    const migrationFiles = await this.fileService.readDir(migrationsDir);\n    \n    // Filter and sort migrations\n    const applicableMigrations = migrationFiles\n      .filter(file => file.endsWith('.ts'))\n      .filter(file => !version || this.shouldApplyMigration(file, version))\n      .sort();\n\n    if (applicableMigrations.length === 0) {\n      this.logger.info('\u2705 No migrations to apply');\n      return;\n    }\n\n    // Apply migrations\n    for (const migrationFile of applicableMigrations) {\n      await this.applyMigration(migrationFile, migrationsDir, force);\n    }\n    \n    this.logger.success(`\ud83c\udf89 Applied ${applicableMigrations.length} migrations`);\n  }\n\n  private shouldApplyMigration(file: string, targetVersion: string): boolean {\n    const fileVersion = file.replace('.ts', '');\n    return this.compareVersions(fileVersion, targetVersion) <= 0;\n  }\n\n  private async applyMigration(file: string, dir: string, force: boolean): Promise<void> {\n    const migrationPath = path.join(dir, file);\n    this.logger.info(`\ud83d\udcdd Applying migration: ${file}`);\n    \n    try {\n      const migration = await import(migrationPath);\n      await migration.default.up();\n      this.logger.success(`\u2705 Migration ${file} completed`);\n    } catch (error) {\n      this.logger.error(`\u274c Migration ${file} failed: ${error.message}`);\n      if (!force) throw error;\n    }\n  }\n\n  private compareVersions(a: string, b: string): number {\n    // Simple semantic version comparison\n    const aParts = a.split('.').map(Number);\n    const bParts = b.split('.').map(Number);\n    \n    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n      const aPart = aParts[i] || 0;\n      const bPart = bParts[i] || 0;\n      if (aPart < bPart) return -1;\n      if (aPart > bPart) return 1;\n    }\n    return 0;\n  }\n}\n\nconst migrateCommand: ICommandDefinition = {\n  name: 'migrate',\n  description: 'Run database or code migrations',\n  options: [\n    {\n      name: 'version',\n      alias: 'v',\n      type: 'string',\n      description: 'Target version to migrate to',\n    },\n    {\n      name: 'force',\n      alias: 'f',\n      type: 'boolean',\n      description: 'Continue on migration errors',\n      default: false,\n    },\n  ],\n  handler: MigrateCommand,\n};\n\nexport default migrateCommand;"}]},{id:"migrations",title:"Version Migrations",description:"Handle package version upgrades and data migrations",icon:"\ud83d\udd04",examples:[{title:"Migration File Structure",description:"How to structure your migration files",language:"typescript",filename:"packages/my-package/migrations/1.2.0.ts",code:"import type { IMigrationDefinition } from '@/types';\nimport { FileService } from '@/core/file';\nimport { Logger } from '@/core/logger';\n\nconst migration_1_2_0: IMigrationDefinition = {\n  version: '1.2.0',\n  description: 'Add TypeScript support and update config files',\n  \n  async up(context: any): Promise<void> {\n    const logger = new Logger();\n    const fileService = new FileService();\n    \n    logger.info('\ud83d\udd04 Migrating to v1.2.0...');\n    \n    // 1. Update package.json\n    await this.updatePackageJson(fileService, context.projectPath);\n    \n    // 2. Add TypeScript config\n    await this.addTypeScriptConfig(fileService, context.projectPath);\n    \n    // 3. Convert JS files to TS\n    await this.convertJavaScriptFiles(fileService, context.projectPath);\n    \n    logger.success('\u2705 Migration to v1.2.0 completed');\n  },\n\n  async down(context: any): Promise<void> {\n    const logger = new Logger();\n    const fileService = new FileService();\n    \n    logger.info('\ud83d\udd04 Rolling back from v1.2.0...');\n    \n    // Rollback steps (reverse order)\n    await this.revertJavaScriptFiles(fileService, context.projectPath);\n    await this.removeTypeScriptConfig(fileService, context.projectPath);\n    await this.revertPackageJson(fileService, context.projectPath);\n    \n    logger.success('\u2705 Rollback from v1.2.0 completed');\n  },\n\n  async updatePackageJson(fileService: FileService, projectPath: string): Promise<void> {\n    const packageJsonPath = `${projectPath}/package.json`;\n    const packageJson = await fileService.readJson(packageJsonPath);\n    \n    // Add TypeScript dependencies\n    packageJson.devDependencies = packageJson.devDependencies || {};\n    Object.assign(packageJson.devDependencies, {\n      'typescript': '^5.0.0',\n      '@types/node': '^20.0.0',\n      '@types/react': '^18.0.0',\n    });\n\n    // Add TypeScript scripts\n    packageJson.scripts = packageJson.scripts || {};\n    packageJson.scripts['type-check'] = 'tsc --noEmit';\n    \n    await fileService.writeJson(packageJsonPath, packageJson);\n  },\n\n  async addTypeScriptConfig(fileService: FileService, projectPath: string): Promise<void> {\n    const tsconfigPath = `${projectPath}/tsconfig.json`;\n    const tsconfig = {\n      compilerOptions: {\n        target: 'ES2022',\n        module: 'ESNext',\n        moduleResolution: 'bundler',\n        allowImportingTsExtensions: true,\n        resolveJsonModule: true,\n        isolatedModules: true,\n        noEmit: true,\n        jsx: 'react-jsx',\n        strict: true,\n        skipLibCheck: true,\n      },\n      include: ['src/**/*'],\n      exclude: ['node_modules', 'dist'],\n    };\n    \n    await fileService.writeJson(tsconfigPath, tsconfig);\n  },\n\n  async convertJavaScriptFiles(fileService: FileService, projectPath: string): Promise<void> {\n    // Implementation for converting .js files to .ts\n    // This would involve parsing, type inference, etc.\n  },\n\n  // Rollback methods...\n  async revertJavaScriptFiles(fileService: FileService, projectPath: string): Promise<void> {\n    // Revert .ts files back to .js\n  },\n\n  async removeTypeScriptConfig(fileService: FileService, projectPath: string): Promise<void> {\n    const tsconfigPath = `${projectPath}/tsconfig.json`;\n    await fileService.remove(tsconfigPath);\n  },\n\n  async revertPackageJson(fileService: FileService, projectPath: string): Promise<void> {\n    // Remove TypeScript-related dependencies and scripts\n  },\n};\n\nexport default migration_1_2_0;"},{title:"Migration Index File",description:"How to export all migrations from your package",language:"typescript",filename:"packages/my-package/migrations/index.ts",code:"import type { IMigrationDefinition } from '@/types';\n\nimport migration_1_0_0 from './1.0.0';\nimport migration_1_1_0 from './1.1.0';\nimport migration_1_2_0 from './1.2.0';\n\nexport const migrations: IMigrationDefinition[] = [\n  migration_1_0_0,\n  migration_1_1_0,\n  migration_1_2_0,\n];\n\nexport {\n  migration_1_0_0,\n  migration_1_1_0,\n  migration_1_2_0,\n};"}]},{id:"templates",title:"Code Templates",description:"Create reusable code templates for scaffolding",icon:"\ud83d\udcdd",examples:[{title:"React Component Template",description:"Template for generating React components",language:"typescript",filename:"packages/jarvis/templates/component.ts",code:"export interface ComponentTemplateOptions {\n  name: string;\n  type: 'functional' | 'class';\n  includeStyles: boolean;\n  includeTests: boolean;\n  propsInterface?: string;\n}\n\nexport const componentTemplate = (options: ComponentTemplateOptions): string => {\n  const { name, type, propsInterface } = options;\n  \n  if (type === 'functional') {\n    return `import React from 'react';\n${options.includeStyles ? `import styles from './${name}.module.css';` : ''}\n\n${propsInterface ? `interface ${name}Props {\n  ${propsInterface}\n}` : `interface ${name}Props {\n  // Add your props here\n}`}\n\nconst ${name}: React.FC<${name}Props> = (props) => {\n  return (\n    <div${options.includeStyles ? ` className={styles.container}` : ''}>\n      <h1>${name} Component</h1>\n      {/* Component content */}\n    </div>\n  );\n};\n\nexport default ${name};\n`;\n  }\n  \n  return `import React, { Component } from 'react';\n${options.includeStyles ? `import styles from './${name}.module.css';` : ''}\n\n${propsInterface ? `interface ${name}Props {\n  ${propsInterface}\n}` : `interface ${name}Props {\n  // Add your props here\n}`}\n\ninterface ${name}State {\n  // Add your state here\n}\n\nclass ${name} extends Component<${name}Props, ${name}State> {\n  constructor(props: ${name}Props) {\n    super(props);\n    this.state = {\n      // Initialize state\n    };\n  }\n\n  render() {\n    return (\n      <div${options.includeStyles ? ` className={styles.container}` : ''}>\n        <h1>${name} Component</h1>\n        {/* Component content */}\n      </div>\n    );\n  }\n}\n\nexport default ${name};\n`;\n};"},{title:"Test Template",description:"Template for generating test files",language:"typescript",filename:"packages/jarvis/templates/component-test.ts",code:"export interface TestTemplateOptions {\n  componentName: string;\n  testFramework: 'jest' | 'vitest';\n  includeSnapshots: boolean;\n}\n\nexport const testTemplate = (options: TestTemplateOptions): string => {\n  const { componentName, testFramework, includeSnapshots } = options;\n  \n  return `import React from 'react';\nimport { render, screen${includeSnapshots ? ', renderer' : ''} } from '@testing-library/react';\n${testFramework === 'vitest' ? \"import { describe, it, expect } from 'vitest';\" : ''}\nimport ${componentName} from './${componentName}';\n\ndescribe('${componentName}', () => {\n  it('renders without crashing', () => {\n    render(<${componentName} />);\n    expect(screen.getByText('${componentName} Component')).toBeInTheDocument();\n  });\n\n  it('displays the correct heading', () => {\n    render(<${componentName} />);\n    const heading = screen.getByRole('heading', { level: 1 });\n    expect(heading).toHaveTextContent('${componentName} Component');\n  });\n\n  ${includeSnapshots ? `it('matches snapshot', () => {\n    const tree = renderer.create(<${componentName} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });` : ''}\n\n  // Add more tests here\n});\n`;\n};"}]},{id:"core-utilities",title:"Core Utilities",description:"Shared utilities for file operations, logging, and process management",icon:"\ud83d\udee0\ufe0f",examples:[{title:"Custom Logger",description:"Package-specific logger with custom formatting",language:"typescript",filename:"packages/my-package/core/logger.ts",code:"import { Logger as BaseLogger } from '@/core/logger';\n\nexport class MyPackageLogger extends BaseLogger {\n  constructor() {\n    super();\n    this.setPrefix('\ud83d\ude80 MY-PACKAGE');\n  }\n\n  deployment(message: string): void {\n    this.log('info', `\ud83d\ude80 [DEPLOY] ${message}`, 'cyan');\n  }\n\n  build(message: string): void {\n    this.log('info', `\ud83d\udd28 [BUILD] ${message}`, 'yellow');\n  }\n\n  test(message: string): void {\n    this.log('info', `\ud83e\uddea [TEST] ${message}`, 'green');\n  }\n\n  performance(message: string, duration?: number): void {\n    const durationText = duration ? ` (${duration}ms)` : '';\n    this.log('info', `\u26a1 [PERF] ${message}${durationText}`, 'magenta');\n  }\n}\n\n// Usage in commands:\n// const logger = new MyPackageLogger();\n// logger.deployment('Starting deployment to production');\n// logger.build('Compiling TypeScript files');\n// logger.performance('Build completed', 1250);"},{title:"File Operations Utility",description:"Enhanced file operations specific to your package needs",language:"typescript",filename:"packages/my-package/core/file.ts",code:"import { FileService as BaseFileService } from '@/core/file';\nimport path from 'path';\nimport { glob } from 'glob';\n\nexport class MyPackageFileService extends BaseFileService {\n  /**\n   * Find all component files in the project\n   */\n  async findComponentFiles(projectPath: string): Promise<string[]> {\n    const patterns = [\n      'src/components/**/*.tsx',\n      'src/components/**/*.jsx',\n      'components/**/*.tsx',\n      'components/**/*.jsx',\n    ];\n\n    const files: string[] = [];\n    for (const pattern of patterns) {\n      const matches = await glob(pattern, { cwd: projectPath });\n      files.push(...matches.map(file => path.join(projectPath, file)));\n    }\n\n    return files;\n  }\n\n  /**\n   * Create a component directory structure\n   */\n  async createComponentStructure(\n    projectPath: string,\n    componentName: string\n  ): Promise<void> {\n    const componentDir = path.join(projectPath, 'src', 'components', componentName);\n    \n    // Create directory\n    await this.ensureDir(componentDir);\n    \n    // Create subdirectories if needed\n    await this.ensureDir(path.join(componentDir, '__tests__'));\n    await this.ensureDir(path.join(componentDir, 'styles'));\n  }\n\n  /**\n   * Read and parse a TypeScript file\n   */\n  async readTypeScriptFile(filePath: string): Promise<{\n    content: string;\n    exports: string[];\n    imports: string[];\n  }> {\n    const content = await this.readFile(filePath);\n    \n    // Simple regex-based parsing (you might want to use a proper TS parser)\n    const exportMatches = content.match(/export\\s+(?:default\\s+)?(?:class|function|const|let|var)\\s+(\\w+)/g) || [];\n    const importMatches = content.match(/import\\s+.*?from\\s+['\"][^'\"]+['\"]/g) || [];\n    \n    const exports = exportMatches.map(match => {\n      const nameMatch = match.match(/\\b(\\w+)$/);\n      return nameMatch ? nameMatch[1] : '';\n    }).filter(Boolean);\n    \n    return {\n      content,\n      exports,\n      imports: importMatches,\n    };\n  }\n\n  /**\n   * Update imports in a file\n   */\n  async updateImports(\n    filePath: string,\n    newImports: { module: string; imports: string[] }[]\n  ): Promise<void> {\n    let content = await this.readFile(filePath);\n    \n    // Add new imports at the top\n    const newImportStatements = newImports\n      .map(({ module, imports }) => {\n        if (imports.includes('default')) {\n          const defaultImport = imports.find(imp => imp === 'default');\n          const namedImports = imports.filter(imp => imp !== 'default');\n          return `import ${defaultImport}${namedImports.length ? `, { ${namedImports.join(', ')} }` : ''} from '${module}';`;\n        }\n        return `import { ${imports.join(', ')} } from '${module}';`;\n      })\n      .join('\\n');\n    \n    content = newImportStatements + '\\n' + content;\n    \n    await this.writeFile(filePath, content);\n  }\n}"},{title:"Process Management",description:"Custom process utilities for running commands and handling output",language:"typescript",filename:"packages/my-package/core/process.ts",code:"import { ProcessService as BaseProcessService } from '@/core/process';\nimport { MyPackageLogger } from './logger';\n\nexport class MyPackageProcessService extends BaseProcessService {\n  private logger = new MyPackageLogger();\n\n  /**\n   * Run npm/yarn/pnpm commands with proper package manager detection\n   */\n  async runPackageManager(\n    command: string,\n    args: string[] = [],\n    options: any = {}\n  ): Promise<void> {\n    const packageManager = await this.detectPackageManager();\n    this.logger.info(`\ud83d\udce6 Running ${packageManager} ${command} ${args.join(' ')}`);\n    \n    await this.run(packageManager, [command, ...args], {\n      stdio: 'inherit',\n      ...options,\n    });\n  }\n\n  /**\n   * Run build tools (webpack, vite, rollup, etc.)\n   */\n  async runBuildTool(\n    tool: string,\n    config?: string,\n    options: string[] = []\n  ): Promise<void> {\n    const args = config ? ['--config', config, ...options] : options;\n    \n    this.logger.build(`\ud83d\udd28 Running ${tool} build`);\n    const startTime = Date.now();\n    \n    try {\n      await this.run(tool, args, { stdio: 'inherit' });\n      const duration = Date.now() - startTime;\n      this.logger.performance('Build completed', duration);\n    } catch (error) {\n      this.logger.error(`\u274c Build failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Run tests with coverage\n   */\n  async runTests(\n    testRunner: 'jest' | 'vitest' = 'jest',\n    coverage = false,\n    watch = false\n  ): Promise<void> {\n    const args: string[] = [];\n    \n    if (coverage) args.push('--coverage');\n    if (watch) args.push('--watch');\n    \n    this.logger.test(`\ud83e\uddea Running tests with ${testRunner}`);\n    \n    try {\n      await this.run(testRunner, args, { stdio: 'inherit' });\n      this.logger.success('\u2705 All tests passed');\n    } catch (error) {\n      this.logger.error('\u274c Tests failed');\n      throw error;\n    }\n  }\n\n  /**\n   * Deploy to various platforms\n   */\n  async deploy(\n    platform: 'vercel' | 'netlify' | 'aws' | 'docker',\n    config: any = {}\n  ): Promise<void> {\n    this.logger.deployment(`\ud83d\ude80 Deploying to ${platform}`);\n    \n    switch (platform) {\n      case 'vercel':\n        await this.deployToVercel(config);\n        break;\n      case 'netlify':\n        await this.deployToNetlify(config);\n        break;\n      case 'aws':\n        await this.deployToAWS(config);\n        break;\n      case 'docker':\n        await this.deployToDocker(config);\n        break;\n      default:\n        throw new Error(`Unsupported platform: ${platform}`);\n    }\n    \n    this.logger.success(`\ud83c\udf89 Successfully deployed to ${platform}`);\n  }\n\n  private async detectPackageManager(): Promise<string> {\n    // Check for lock files to determine package manager\n    if (await this.fileExists('pnpm-lock.yaml')) return 'pnpm';\n    if (await this.fileExists('yarn.lock')) return 'yarn';\n    return 'npm';\n  }\n\n  private async deployToVercel(config: any): Promise<void> {\n    const args = ['--prod'];\n    if (config.token) args.push('--token', config.token);\n    await this.run('vercel', args);\n  }\n\n  private async deployToNetlify(config: any): Promise<void> {\n    const args = ['deploy', '--prod'];\n    if (config.site) args.push('--site', config.site);\n    await this.run('netlify', args);\n  }\n\n  private async deployToAWS(config: any): Promise<void> {\n    // AWS deployment logic\n    await this.run('aws', ['s3', 'sync', './dist', `s3://${config.bucket}`]);\n  }\n\n  private async deployToDocker(config: any): Promise<void> {\n    const tag = config.tag || 'latest';\n    await this.run('docker', ['build', '-t', tag, '.']);\n    if (config.push) {\n      await this.run('docker', ['push', tag]);\n    }\n  }\n}"}]},{id:"best-practices",title:"Best Practices",description:"Guidelines and patterns for building maintainable CLI packages",icon:"\ud83c\udf1f",examples:[{title:"Command Validation",description:"How to validate command inputs and provide helpful error messages",language:"typescript",code:"import type { ICommandDefinition } from '@/types';\nimport { injectable, inject } from 'inversify';\nimport { Logger } from '@/core/logger';\nimport { FileService } from '@/core/file';\n\n@injectable()\nexport class ValidatedCommand {\n  constructor(\n    @inject('Logger') private logger: Logger,\n    @inject('FileService') private fileService: FileService\n  ) {}\n\n  async execute(options: any, context: any): Promise<void> {\n    // Validate environment\n    await this.validateEnvironment(context);\n    \n    // Validate options\n    this.validateOptions(options);\n    \n    // Validate project state\n    await this.validateProjectState(context.projectPath);\n    \n    // Execute command logic\n    await this.executeCommand(options, context);\n  }\n\n  private async validateEnvironment(context: any): Promise<void> {\n    // Check Node.js version\n    const nodeVersion = process.version;\n    const requiredVersion = '16.0.0';\n    \n    if (!this.isVersionCompatible(nodeVersion.slice(1), requiredVersion)) {\n      throw new Error(\n        `\u274c Node.js ${requiredVersion}+ required. Current: ${nodeVersion}`\n      );\n    }\n\n    // Check if required tools are installed\n    const requiredTools = ['git', 'npm'];\n    for (const tool of requiredTools) {\n      if (!(await this.isCommandAvailable(tool))) {\n        throw new Error(`\u274c Required tool not found: ${tool}`);\n      }\n    }\n  }\n\n  private validateOptions(options: any): void {\n    // Validate required options\n    if (options.env && !['development', 'staging', 'production'].includes(options.env)) {\n      throw new Error(\n        `\u274c Invalid environment: ${options.env}. Must be: development, staging, or production`\n      );\n    }\n\n    // Validate file paths\n    if (options.config && !this.isValidPath(options.config)) {\n      throw new Error(`\u274c Invalid config path: ${options.config}`);\n    }\n\n    // Validate port numbers\n    if (options.port && (options.port < 1 || options.port > 65535)) {\n      throw new Error(`\u274c Invalid port: ${options.port}. Must be between 1-65535`);\n    }\n  }\n\n  private async validateProjectState(projectPath: string): Promise<void> {\n    // Check if package.json exists\n    const packageJsonPath = `${projectPath}/package.json`;\n    if (!(await this.fileService.exists(packageJsonPath))) {\n      throw new Error('\u274c No package.json found. Are you in a valid project directory?');\n    }\n\n    // Validate package.json structure\n    const packageJson = await this.fileService.readJson(packageJsonPath);\n    if (!packageJson.name) {\n      throw new Error('\u274c package.json must have a name field');\n    }\n\n    // Check for conflicting processes\n    if (await this.isPortInUse(3000)) {\n      this.logger.warn('\u26a0\ufe0f  Port 3000 is already in use');\n    }\n  }\n\n  private isVersionCompatible(current: string, required: string): boolean {\n    const currentParts = current.split('.').map(Number);\n    const requiredParts = required.split('.').map(Number);\n    \n    for (let i = 0; i < requiredParts.length; i++) {\n      if (currentParts[i] < requiredParts[i]) return false;\n      if (currentParts[i] > requiredParts[i]) return true;\n    }\n    return true;\n  }\n\n  private async isCommandAvailable(command: string): Promise<boolean> {\n    try {\n      await this.run('which', [command]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private isValidPath(path: string): boolean {\n    return /^[^<>:\"|?*\\x00-\\x1f]+$/.test(path);\n  }\n\n  // ... other validation methods\n}"},{title:"Error Handling",description:"Comprehensive error handling with user-friendly messages",language:"typescript",code:"import type { ICommandDefinition } from '@/types';\nimport { injectable, inject } from 'inversify';\nimport { Logger } from '@/core/logger';\n\nexport class CommandError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public suggestions: string[] = []\n  ) {\n    super(message);\n    this.name = 'CommandError';\n  }\n}\n\n@injectable()\nexport class RobustCommand {\n  constructor(\n    @inject('Logger') private logger: Logger\n  ) {}\n\n  async execute(options: any, context: any): Promise<void> {\n    try {\n      await this.executeWithErrorHandling(options, context);\n    } catch (error) {\n      await this.handleError(error, options, context);\n    }\n  }\n\n  private async executeWithErrorHandling(options: any, context: any): Promise<void> {\n    // Wrap potentially failing operations\n    try {\n      await this.performNetworkOperation();\n    } catch (error) {\n      throw new CommandError(\n        'Failed to connect to remote service',\n        'NETWORK_ERROR',\n        [\n          'Check your internet connection',\n          'Verify the service URL is correct',\n          'Try again in a few moments',\n        ]\n      );\n    }\n\n    try {\n      await this.performFileOperation();\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new CommandError(\n          `File not found: ${error.path}`,\n          'FILE_NOT_FOUND',\n          [\n            'Check if the file path is correct',\n            'Ensure the file exists and is readable',\n            `Run 'ls -la ${error.path}' to check permissions`,\n          ]\n        );\n      }\n      throw error;\n    }\n  }\n\n  private async handleError(error: Error, options: any, context: any): Promise<void> {\n    if (error instanceof CommandError) {\n      // Handle custom command errors\n      this.logger.error(`\u274c ${error.message}`);\n      \n      if (error.suggestions.length > 0) {\n        this.logger.info('\ud83d\udca1 Suggestions:');\n        error.suggestions.forEach((suggestion, index) => {\n          this.logger.info(`   ${index + 1}. ${suggestion}`);\n        });\n      }\n\n      // Provide context-specific help\n      if (error.code === 'NETWORK_ERROR' && options.offline) {\n        this.logger.info('\u2139\ufe0f  You can try running in offline mode with --offline flag');\n      }\n\n    } else if (error.code === 'EACCES') {\n      // Permission errors\n      this.logger.error('\u274c Permission denied');\n      this.logger.info('\ud83d\udca1 Try running with appropriate permissions:');\n      this.logger.info('   sudo shuriken <command>');\n      \n    } else if (error.code === 'ENOSPC') {\n      // Disk space errors\n      this.logger.error('\u274c Insufficient disk space');\n      this.logger.info('\ud83d\udca1 Free up disk space and try again');\n      \n    } else {\n      // Unexpected errors\n      this.logger.error(`\u274c Unexpected error: ${error.message}`);\n      \n      if (options.debug) {\n        this.logger.error('Stack trace:');\n        this.logger.error(error.stack || 'No stack trace available');\n      } else {\n        this.logger.info('\ud83d\udca1 Run with --debug flag for more details');\n      }\n    }\n\n    // Log error for debugging\n    this.logger.debug(`Error details: ${JSON.stringify({\n      name: error.name,\n      message: error.message,\n      code: error.code,\n      stack: error.stack,\n    }, null, 2)}`);\n\n    // Exit with appropriate code\n    process.exit(1);\n  }\n\n  private async performNetworkOperation(): Promise<void> {\n    // Network operation that might fail\n  }\n\n  private async performFileOperation(): Promise<void> {\n    // File operation that might fail\n  }\n}"},{title:"Configuration Management",description:"Best practices for handling configuration files and user settings",language:"typescript",code:"import type { ICommandDefinition } from '@/types';\nimport { injectable, inject } from 'inversify';\nimport { FileService } from '@/core/file';\nimport { Logger } from '@/core/logger';\nimport path from 'path';\nimport os from 'os';\n\ninterface PackageConfig {\n  version: string;\n  preferences: {\n    theme: 'light' | 'dark';\n    verbosity: 'quiet' | 'normal' | 'verbose';\n    autoUpdate: boolean;\n  };\n  tools: {\n    editor: string;\n    browser: string;\n    terminal: string;\n  };\n  projects: Array<{\n    name: string;\n    path: string;\n    type: string;\n  }>;\n}\n\n@injectable()\nexport class ConfigurableCommand {\n  private configPath: string;\n  private config: PackageConfig | null = null;\n\n  constructor(\n    @inject('FileService') private fileService: FileService,\n    @inject('Logger') private logger: Logger\n  ) {\n    this.configPath = path.join(os.homedir(), '.shuriken', 'my-package.json');\n  }\n\n  async execute(options: any, context: any): Promise<void> {\n    // Load configuration\n    await this.loadConfig();\n    \n    // Merge with command options\n    const effectiveConfig = this.mergeConfig(options);\n    \n    // Execute with configuration\n    await this.executeWithConfig(effectiveConfig, context);\n  }\n\n  private async loadConfig(): Promise<void> {\n    try {\n      if (await this.fileService.exists(this.configPath)) {\n        this.config = await this.fileService.readJson(this.configPath);\n        this.validateConfig(this.config);\n      } else {\n        this.config = this.getDefaultConfig();\n        await this.saveConfig();\n      }\n    } catch (error) {\n      this.logger.warn(`\u26a0\ufe0f  Failed to load config: ${error.message}`);\n      this.logger.info('\ud83d\udcdd Using default configuration');\n      this.config = this.getDefaultConfig();\n    }\n  }\n\n  private getDefaultConfig(): PackageConfig {\n    return {\n      version: '1.0.0',\n      preferences: {\n        theme: 'dark',\n        verbosity: 'normal',\n        autoUpdate: true,\n      },\n      tools: {\n        editor: process.env.EDITOR || 'code',\n        browser: process.env.BROWSER || 'chrome',\n        terminal: process.env.TERMINAL || 'Terminal',\n      },\n      projects: [],\n    };\n  }\n\n  private validateConfig(config: any): void {\n    const requiredFields = ['version', 'preferences', 'tools', 'projects'];\n    for (const field of requiredFields) {\n      if (!(field in config)) {\n        throw new Error(`Missing required config field: ${field}`);\n      }\n    }\n\n    // Validate enum values\n    if (!['light', 'dark'].includes(config.preferences.theme)) {\n      config.preferences.theme = 'dark';\n      this.logger.warn('\u26a0\ufe0f  Invalid theme in config, using default: dark');\n    }\n\n    if (!['quiet', 'normal', 'verbose'].includes(config.preferences.verbosity)) {\n      config.preferences.verbosity = 'normal';\n      this.logger.warn('\u26a0\ufe0f  Invalid verbosity in config, using default: normal');\n    }\n  }\n\n  private mergeConfig(options: any): PackageConfig {\n    const merged = JSON.parse(JSON.stringify(this.config));\n\n    // Override with command-line options\n    if (options.theme) merged.preferences.theme = options.theme;\n    if (options.verbose) merged.preferences.verbosity = 'verbose';\n    if (options.quiet) merged.preferences.verbosity = 'quiet';\n    if (options.editor) merged.tools.editor = options.editor;\n\n    return merged;\n  }\n\n  private async saveConfig(): Promise<void> {\n    try {\n      await this.fileService.ensureDir(path.dirname(this.configPath));\n      await this.fileService.writeJson(this.configPath, this.config, { spaces: 2 });\n    } catch (error) {\n      this.logger.warn(`\u26a0\ufe0f  Failed to save config: ${error.message}`);\n    }\n  }\n\n  private async executeWithConfig(config: PackageConfig, context: any): Promise<void> {\n    // Set logger verbosity\n    this.logger.setLevel(\n      config.preferences.verbosity === 'quiet' ? 'error' :\n      config.preferences.verbosity === 'verbose' ? 'debug' : 'info'\n    );\n\n    // Use configured tools\n    if (config.tools.editor) {\n      process.env.EDITOR = config.tools.editor;\n    }\n\n    // Apply theme\n    if (config.preferences.theme === 'dark') {\n      this.logger.setColorScheme('dark');\n    }\n\n    // Command implementation using config...\n    this.logger.info(`\ud83c\udfaf Running with ${config.preferences.theme} theme`);\n  }\n\n  // Utility method for other commands to access config\n  async getConfig(): Promise<PackageConfig> {\n    if (!this.config) {\n      await this.loadConfig();\n    }\n    return this.config!;\n  }\n\n  async updateConfig(updates: Partial<PackageConfig>): Promise<void> {\n    if (!this.config) {\n      await this.loadConfig();\n    }\n    \n    this.config = { ...this.config!, ...updates };\n    await this.saveConfig();\n    this.logger.success('\u2705 Configuration updated');\n  }\n}"}]}],a=()=>{const[e,n]=(0,i.useState)("package-structure"),[t,a]=(0,i.useState)(!0),[c,l]=(0,i.useState)(null);i.useEffect((()=>{document.documentElement.setAttribute("data-theme",t?"dark":"light")}),[t]);const p=s.find((n=>n.id===e));return(0,r.jsxs)("div",{className:"min-h-screen bg-background text-foreground transition-colors duration-300",children:[(0,r.jsx)(o.A,{href:"/",children:(0,r.jsx)("header",{className:"border-b border-border bg-card sticky top-0 z-50",children:(0,r.jsx)("div",{className:"container mx-auto px-4 py-4",children:(0,r.jsxs)("div",{className:"flex items-center justify-between",children:[(0,r.jsxs)("div",{className:"flex items-center space-x-4",children:[(0,r.jsx)("div",{className:"text-3xl",children:"\ud83e\udd77"}),(0,r.jsxs)("div",{children:[(0,r.jsx)("h1",{className:"text-2xl font-bold text-primary",children:"Shuriken CLI"}),(0,r.jsx)("p",{className:"text-muted-foreground text-sm",children:"Developer Examples & Documentation"})]})]}),(0,r.jsx)("button",{onClick:()=>a(!t),className:"p-2 rounded-md hover:bg-accent transition-colors","aria-label":"Toggle theme",children:t?"\u2600\ufe0f":"\ud83c\udf19"})]})})})}),(0,r.jsxs)("div",{className:"container mx-auto px-4 py-8 max-w-7xl",children:[(0,r.jsxs)("section",{className:"text-center mb-12",children:[(0,r.jsx)("h2",{className:"text-3xl font-bold mb-4 text-primary",children:"\ud83d\udcda Developer Examples"}),(0,r.jsx)("p",{className:"text-muted-foreground mb-8 max-w-3xl mx-auto text-lg",children:"Learn how to extend Shuriken CLI with custom packages, commands, and utilities. These examples will help you build powerful CLI tools for your organization."})]}),(0,r.jsxs)("div",{className:"grid lg:grid-cols-4 gap-8",children:[(0,r.jsx)("nav",{className:"lg:col-span-1",children:(0,r.jsxs)("div",{className:"bg-card border border-border rounded-lg p-4 sticky top-24",children:[(0,r.jsx)("h3",{className:"font-semibold mb-4 text-primary",children:"\ud83d\udcd6 Sections"}),(0,r.jsx)("ul",{className:"space-y-2",children:s.map((t=>(0,r.jsx)("li",{children:(0,r.jsxs)("button",{onClick:()=>n(t.id),className:"w-full text-left px-3 py-2 rounded-md transition-colors text-sm "+(e===t.id?"bg-primary text-primary-foreground":"hover:bg-accent"),children:[(0,r.jsx)("span",{className:"mr-2",children:t.icon}),t.title]})},t.id)))})]})}),(0,r.jsx)("main",{className:"lg:col-span-3",children:p&&(0,r.jsxs)("div",{children:[(0,r.jsxs)("div",{className:"mb-8",children:[(0,r.jsxs)("div",{className:"flex items-center space-x-3 mb-4",children:[(0,r.jsx)("span",{className:"text-3xl",children:p.icon}),(0,r.jsx)("h2",{className:"text-2xl font-bold text-primary",children:p.title})]}),(0,r.jsx)("p",{className:"text-muted-foreground text-lg",children:p.description})]}),(0,r.jsx)("div",{className:"space-y-8",children:p.examples.map(((n,t)=>(0,r.jsxs)("div",{className:"bg-card border border-border rounded-lg overflow-hidden",children:[(0,r.jsx)("div",{className:"bg-muted px-6 py-4 border-b border-border",children:(0,r.jsxs)("div",{className:"flex items-center justify-between",children:[(0,r.jsxs)("div",{children:[(0,r.jsx)("h3",{className:"font-semibold text-lg text-primary",children:n.title}),(0,r.jsx)("p",{className:"text-muted-foreground text-sm mt-1",children:n.description}),n.filename&&(0,r.jsxs)("p",{className:"text-xs font-mono mt-2 text-blue-600 dark:text-blue-400",children:["\ud83d\udcc1 ",n.filename]})]}),(0,r.jsx)("button",{onClick:()=>(async(e,n)=>{try{await navigator.clipboard.writeText(e),l(n),setTimeout((()=>l(null)),2e3)}catch(t){console.error("Failed to copy code:",t)}})(n.code,`${e}-${t}`),className:"p-2 rounded-md hover:bg-accent transition-colors",title:"Copy code",children:c===`${e}-${t}`?(0,r.jsx)("span",{className:"text-green-500",children:"\u2705"}):(0,r.jsx)("span",{children:"\ud83d\udccb"})})]})}),(0,r.jsx)("div",{className:"relative",children:(0,r.jsx)("pre",{className:"overflow-x-auto p-6 text-sm font-mono bg-card",children:(0,r.jsx)("code",{className:"language-typescript",children:n.code})})})]},t)))})]})})]}),(0,r.jsxs)("section",{className:"mt-16 bg-card border border-border rounded-lg p-8",children:[(0,r.jsxs)("div",{className:"text-center mb-8",children:[(0,r.jsx)("h2",{className:"text-2xl font-bold text-primary mb-4",children:"\ud83d\ude80 Quick Start"}),(0,r.jsx)("p",{className:"text-muted-foreground",children:"Ready to create your first package? Follow these steps:"})]}),(0,r.jsxs)("div",{className:"grid md:grid-cols-3 gap-6",children:[(0,r.jsxs)("div",{className:"text-center",children:[(0,r.jsx)("div",{className:"bg-primary text-primary-foreground w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-4 text-xl font-bold",children:"1"}),(0,r.jsx)("h3",{className:"font-semibold mb-2",children:"Scaffold Package"}),(0,r.jsxs)("p",{className:"text-muted-foreground text-sm",children:["Run"," ",(0,r.jsx)("code",{className:"bg-muted px-2 py-1 rounded",children:"pnpm run prepare-package"})," ","to create a new package structure"]})]}),(0,r.jsxs)("div",{className:"text-center",children:[(0,r.jsx)("div",{className:"bg-primary text-primary-foreground w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-4 text-xl font-bold",children:"2"}),(0,r.jsx)("h3",{className:"font-semibold mb-2",children:"Add Commands"}),(0,r.jsxs)("p",{className:"text-muted-foreground text-sm",children:["Create command files in the"," ",(0,r.jsx)("code",{className:"bg-muted px-2 py-1 rounded",children:"commands/"})," ","directory following our examples"]})]}),(0,r.jsxs)("div",{className:"text-center",children:[(0,r.jsx)("div",{className:"bg-primary text-primary-foreground w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-4 text-xl font-bold",children:"3"}),(0,r.jsx)("h3",{className:"font-semibold mb-2",children:"Test & Use"}),(0,r.jsxs)("p",{className:"text-muted-foreground text-sm",children:["Run"," ",(0,r.jsx)("code",{className:"bg-muted px-2 py-1 rounded",children:"shuriken your-package command"})," ","to test your new CLI tools"]})]})]})]}),(0,r.jsx)("footer",{className:"mt-16 text-center",children:(0,r.jsx)("div",{className:"border-t border-border pt-8",children:(0,r.jsxs)("p",{className:"text-muted-foreground",children:["Need help? Check out our"," ",(0,r.jsx)("a",{href:"https://github.com/soheilnikroo/shuriken",className:"text-primary hover:underline",target:"_blank",rel:"noopener noreferrer",children:"GitHub repository"})," ","or join our community discussions."]})})})]})]})}}}]);